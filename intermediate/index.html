<html>
<head></head>
<body>
<script>


function telephoneCheck(str) {
	// Good luck!
	/*
		VALID FORMATS
		555-555-5555
		(555)555-5555
		(555) 555-5555
		555 555 5555
		5555555555
		1 555 555 5555
	*/

	var patt = /^1? ?(\(\d{3}\)|\d{3})[-| ]?\d{3}[-| ]?\d{4}$/;
	var res = patt.test(str);

	console.log(res);
	return res;
}

/*
telephoneCheck("2(757)622-7382");
// should return false.
telephoneCheck("(555)5(55?)-5555");
// should return false.
telephoneCheck("27576227382");
// should return false.
telephoneCheck("(275)76227382");
// should return false.
telephoneCheck("2 757 622-7382");
// should return false.
telephoneCheck("1 555)555-5555");
// should return false.
telephoneCheck("555)-555-5555");
// should return false.
telephoneCheck("(555-555-5555");
// should return false.
telephoneCheck("555-555-5555");
// should return a boolean.
telephoneCheck("1 555-555-5555");
// should return true.
telephoneCheck("1 (555) 555-5555");
// should return true.
telephoneCheck("5555555555");
// should return true.
telephoneCheck("555-555-5555");
// should return true.
telephoneCheck("(555)555-5555");
// should return true.
telephoneCheck("1(555)555-5555");
// should return true.
telephoneCheck("555-5555");
// should return false.
telephoneCheck("5555555");
// should return false.
//telephoneCheck("1 555 555 5555");
// should return true.
//telephoneCheck("1 456 789 4444");
// should return true.
//telephoneCheck("123**&!!asdf#");
// should return false.
//telephoneCheck("55555555");
// should return false.
//telephoneCheck("(6505552368)");
// should return false
//telephoneCheck("2 (757) 622-7382");
// should return false.
//telephoneCheck("0 (757) 622-7382");
// should return false.
//telephoneCheck("-1 (757) 622-7382");
// should return false
//telephoneCheck("10 (757) 622-7382");
// should return false.
//telephoneCheck("2(757)6227382");
// should return false.
*/


/*
function addTogether(a, b) {

	if(typeof a !== 'number'){
		console.log('undefined');
		return undefined;
	}

	if(! b){
		return function(c){
			if(typeof c !== 'number'){
				console.log('undefined');
				return undefined;
			}
			console.log('no b = '+(a + c));
			return a + c;
		};
	}else{

		if(typeof b !== 'number'){
			console.log('undefined');
			return undefined;
		}

		console.log('a + b = '+(a + b));
		return a + b;
	}

}

addTogether(2, 3);
// should return 5.
addTogether(2)(3);
// should return 5.
addTogether("http://bit.ly/IqT6zt");
// should return undefined.
addTogether(2, "3");
// should return undefined.
addTogether(2)([3]);
// should return undefined.
*/


/*
function truthCheck(collection, pre) {
	// Is everyone being true?
	for(var c = 0; c < collection.length; c++){
		if(! collection[c][pre]) {
			return false;
		}
	}

	return true;
}

truthCheck([{"user": "Tinky-Winky", "sex": "male"}, {"user": "Dipsy", "sex": "male"}, {"user": "Laa-Laa", "sex": "female"}, {"user": "Po", "sex": "female"}], "sex");
// should return true.
truthCheck([{"user": "Tinky-Winky", "sex": "male"}, {"user": "Dipsy"}, {"user": "Laa-Laa", "sex": "female"}, {"user": "Po", "sex": "female"}], "sex");
// should return false.
truthCheck([{"user": "Tinky-Winky", "sex": "male", "age": 0}, {"user": "Dipsy", "sex": "male", "age": 3}, {"user": "Laa-Laa", "sex": "female", "age": 5}, {"user": "Po", "sex": "female", "age": 4}], "age");
// should return false.
truthCheck([{"name": "Pete", "onBoat": true}, {"name": "Repeat", "onBoat": true}, {"name": "FastFoward", "onBoat": null}], "onBoat");
// should return false
truthCheck([{"name": "Pete", "onBoat": true}, {"name": "Repeat", "onBoat": true, "alias": "Repete"}, {"name": "FastFoward", "onBoat": true}], "onBoat");
// should return true
truthCheck([{"single": "yes"}], "single");
// should return true
truthCheck([{"single": ""}, {"single": "double"}], "single");
// should return false
truthCheck([{"single": "double"}, {"single": undefined}], "single");
// should return false
truthCheck([{"single": "double"}, {"single": NaN}], "single");
// should return false
*/


/*
function binaryAgent(str) {
	var bytes = str.split(' '),
		sentence = '';

	//we need to loop through our array of bytes to figure out what each letter is
	for(var l = 0; l < bytes.length; l++){
		//now we split this byte into bits and reverse it. Don't NEED to reverse, but I prefer this route
		var bits = bytes[l].split('').reverse(),
			charCode = 0;
		for(var b = 0, position = 1; b < bits.length; b++, position *= 2){
			if(bits[b] === "1"){
				//as we move through our bits, if we find a 1 we want to add that position's value to our charcode.
				charCode += position;
			}

		}

		//by this point we have our charCode and can add the next char to the string
		sentence += String.fromCharCode(charCode);
	}

	console.log(sentence);
	return sentence;
}

binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111");
// should return "Aren't bonfires fun!?"
binaryAgent("01001001 00100000 01101100 01101111 01110110 01100101 00100000 01000110 01110010 01100101 01100101 01000011 01101111 01100100 01100101 01000011 01100001 01101101 01110000 00100001");
// should return "I love FreeCodeCamp!"
*/

/*
function steamrollArray(arr) {
	// I'm a steamroller, baby
	var steamRollArr = [].concat.apply([], arr);

	for(var i = 0; i < steamRollArr.length; i++){
		if(Array.isArray(steamRollArr[i])){
			steamRollArr[i] = steamRollArr[i][0][0];
		}
	}

	return steamRollArr;
}


steamrollArray([[["a"]], [["b"]]]);
// should return ["a", "b"].
steamrollArray([1, [2], [3, [[4]]]]);
// should return [1, 2, 3, 4].
steamrollArray([1, [], [3, [[4]]]]);
// should return [1, 3, 4].
steamrollArray([1, {}, [3, [[4]]]]);
// should return [1, {}, 3, 4].
*/

/*
function dropElements(arr, func) {
	// Drop them elements.
	var theTruth = [];

	for(var i = 0; i < arr.length; i++){

		if(func(arr[i])){
			//we found the truth, now tell the people!

			//we are slicing arr from the point of success until the end of the array.
			//slice is weird in that the 2nd value is not 0 indexed, but 1 indexed.
			theTruth = arr.slice(i,arr.length);

			return theTruth;
		}

	}

	//if we get here, return empty array
	return theTruth;
}

dropElements([1, 2, 3, 4], function(n) {return n >= 3;});
// should return [3, 4].
dropElements([0, 1, 0, 1], function(n) {return n === 1;});
// should return [1, 0, 1].
dropElements([1, 2, 3], function(n) {return n > 0;});
// should return [1, 2, 3].
dropElements([1, 2, 3, 4], function(n) {return n > 5;});
// should return [].
dropElements([1, 2, 3, 7, 4], function(n) {return n > 3;});
// should return [7, 4].
dropElements([1, 2, 3, 9, 2], function(n) {return n > 2;});
// should return [3, 9, 2].
*/

/*
function findElement(arr, func) {

	for(var i = 0; i < arr.length; i++){
		if(func(arr[i])){
			return arr[i];
		}
	}

	return undefined;

}

findElement([1, 3, 5, 8, 9, 10], function(num) { return num % 2 === 0; });
// should return 8.
findElement([1, 3, 5, 9], function(num) { return num % 2 === 0; });
// should return undefined.
*/

/*
function smallestCommons(arr) {
		//order our array so we know which number is smallest and which is largest
	var sortedArr = arr.sort(),
		//the divisor that successfully divides all numbers in the range to 0
		ourDivisor = 0,
		//smallest multiple will always be the largest number * 1;
		multiple = sortedArr[1];

	while(ourDivisor === 0) {
		//check all numbers in our range
		for(var i = sortedArr[0]; i <= sortedArr[1]; i++ ){
			if(multiple % i !== 0 ){
				//if we find even one value between our set that is not perfectly divisible, we can skip to the next multiple
				break;
			}

			//if we make it all the way to the last value (sortedArr[1]) then we know that this multiple was perfectly divisible into all values in the range
			if(i == sortedArr[1]){
				ourDivisor = multiple;
			}

		}

		//move to the next multiple, we can just add the highest number.
		multiple += sortedArr[1];
	}

	console.log(ourDivisor);
	return ourDivisor;
}


smallestCommons([1, 5]);
// should return 60.
smallestCommons([5, 1]);
// should return 60.
smallestCommons([1, 13]);
// should return 360360.
smallestCommons([23, 18]);
// should return 6056820.
*/

/*
function sumPrimes(num) {
	var sum = 0;

	loop1:
	for(var i = 2; i <= num; i++) {
		//for i gives us a number to check that is less than or equal to num
		//we only need to check half the total value of i since any greater than that will not divide i evenly. I added the +1 since the rounding can cause issues
		for(var j = 2; j < Math.floor(i / 2) + 1; j++){
			//check if this number (i) is divisible by any other number. To do that we loop through all of the numbers below it.
			if(i % j === 0){
				continue loop1;
			}
		}
		//if we got this far it means this number was not divisible by ANYTHING so it is a prime
		sum += i;
	}
	console.log(sum);
	return sum;
}


sumPrimes(10);
//should return 17.
sumPrimes(977);
//should 73156
*/

/*
function sumFibs(num) {
	//1,1,2,3,5,8,13
	var fibPrevious = 1,
		fibStep = 1,
		fibCurrent = 1,
		sum = fibPrevious;

	while(fibCurrent <= num){
		//only add odd numbers
		if(fibCurrent % 2 != 0){
			sum += fibCurrent;
		}

		//update the fib sequence
		fibStep = fibPrevious; //hold our current fibPrevious value for adding to. We do this because we need an intermidiary between our previous and current steps
		fibPrevious = fibCurrent; //our previous fib number will always be equal to the fib number we just used
		fibCurrent += fibStep; //we need to increment our current fib number with the previous fib number
	}

	return sum;
}

sumFibs(1)
//should return a number.
sumFibs(1000)
//should return 1785.
sumFibs(4000000)
//should return 4613732.
sumFibs(4)
//should return 5.
sumFibs(75024)
//should return 60696.
sumFibs(75025)
//should return 135721.
*/

/*
function spinalCase(str) {
	// "It's such a fine line between stupid, and clever."
	// --David St. Hubbins
	str = str.replace(/_/g, ' ');
	str = str.replace(/ /g, '-');
	str = str.replace(/([a-z])([A-Z])/g, function(match,m1,m2){
		return m1+'-'+m2;
	});

	return str.toLowerCase();
}

spinalCase("This Is Spinal Tap");
// should return "this-is-spinal-tap".
spinalCase("thisIsSpinalTap");
// should return "this-is-spinal-tap".
spinalCase("The_Andy_Griffith_Show");
// should return "the-andy-griffith-show".
spinalCase("Teletubbies say Eh-oh");
// should return "teletubbies-say-eh-oh".
spinalCase("AllThe-small Things");
// should return "all-the-small-things".
*/

/*
function convertHTML(str) {
  // &colon;&rpar;
	str = str.replace(/(&|<|>|'|\")/g, function(found){

		switch(found){
			case '&':
				return '&amp;';
			case '<':
				return '&lt;';
			case '>':
				return '&gt;';
			case "'":
				return '&apos;';
			case '"':
				return '&quot;';

		}
	});

	console.log(str);

	return str;
}
*/
/*
convertHTML("Dolce & Gabbana");
// should return Dolce &​amp; Gabbana.
convertHTML("Hamburgers < Pizza < Tacos");
// should return Hamburgers &​lt; Pizza &​lt; Tacos.
convertHTML("Sixty > twelve");
// should return Sixty &​gt; twelve.
convertHTML('Stuff in "quotation marks"');
// should return Stuff in &​quot;quotation marks&​quot;.
convertHTML("Shindler's List");
// should return Shindler&​apos;s List.
convertHTML("<>");
// should return &​lt;&​gt;.
convertHTML("abc");
// should return abc.
*/

/*
function uniteUnique(arr) {
	var args = Array.prototype.slice.call(arguments);

	var flattened = args.reduce(function(a, b) {

		for(var i = 0; i < b.length; i++ ){
			if(a.indexOf(b[i]) == -1){
				if(typeof b[i] == 'object'){
					a.push(b[i]);
				}else{
					a = a.concat(b[i]);
				}

			}
		}

		return a;
	});

	return flattened;
}

//uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]);
// should return [1, 3, 2, 5, 4].
uniteUnique([1, 3, 2], [1, [5]], [2, [4]]);
// should return [1, 3, 2, [5], [4]].
//uniteUnique([1, 2, 3], [5, 2, 1]);
// should return [1, 2, 3, 5].
//uniteUnique([1, 2, 3], [5, 2, 1, 4], [2, 1], [6, 7, 8]);
// should return [1, 2, 3, 5, 4, 6, 7, 8].
*/


/*
function booWho(bool) {
  // What is the new fad diet for ghost developers? The Boolean.
	return bool === true || bool === false?true:false;
}

booWho(true);
// should return true.
booWho(false);
// should return true.
booWho([1, 2, 3]);
// should return false.
booWho([].slice);
// should return false.
booWho({ "a": 1 });
// should return false.
booWho(1);
// should return false.
booWho(NaN);
// should return false.
booWho("a");
// should return false.
booWho("true");
// should return false.
booWho("false");
// should return false.
*/

/*
function fearNotLetter(str) {
	var lastCharCode = str.charCodeAt(0);

	for(var i = 1; i < str.length; i++){

		if(++lastCharCode != str.charCodeAt(i)){
			return String.fromCharCode(lastCharCode);
		}

	}

	return undefined;
}

fearNotLetter("abce");
// should return "d".
fearNotLetter("abcdefghjklmno");
// should return "i".
fearNotLetter("bcd");
// should return undefined.
fearNotLetter("yz");
// should return undefined.
*/

/*
function pairElement(str) {
	DNArr = [],
	elementArr = str.split('');

	elementArr.forEach(function(val){
		switch(val){
			case 'A':
				DNArr.push([val, 'T']);
				break;
			case 'T':
				DNArr.push([val, 'A']);
				break;
			case 'G':
				DNArr.push([val, 'C']);
				break;
			case 'C':
				DNArr.push([val,'G']);
				break;
		}

	})

	return DNArr;
}

pairElement("GCG");
// should return [["G", "C"], ["C","G"],["G", "C"]]
//pairElement("ATCGA");
// should return [["A","T"],["T","A"],["C","G"],["G","C"],["A","T"]].
//pairElement("TTGAG");
// should return [["T","A"],["T","A"],["G","C"],["A","T"],["G","C"]].
//pairElement("CTCTA");
// should return [["C","G"],["T","A"],["C","G"],["T","A"],["A","T"]].
*/

/*
function translatePigLatin(str) {
	var vowels = ['a', 'e', 'i', 'o', 'u'],
		strArr = str.split(''),
		newString = '';

	if(vowels.indexOf(strArr[0]) == -1){
		//no vowel 1
		var firstChars = strArr.shift();
		if(vowels.indexOf(strArr[0]) == -1){
			firstChars += strArr.shift();
			newString = strArr.join('')+firstChars+'ay';
		}else{
			newString = strArr.join('')+firstChars+'ay';
		}


	} else {
		//vowels
		newString = strArr.join('')+'way';

	}

	return newString;
}


translatePigLatin("consonant");
translatePigLatin("california");
//should return "aliforniacay".
translatePigLatin("paragraphs");
// should return "aragraphspay".
translatePigLatin("glove");
// should return "oveglay".
translatePigLatin("algorithm");
// should return "algorithmway".
translatePigLatin("eight");
// should return "eightway".
*/
/*
function myReplace(str, before, after) {
	str = str.replace(before, function(val){
		after = after.split('');

		if (val[0] === val[0].toUpperCase()) {
			after[0] = after[0].toUpperCase();
		}else{
			after[0] = after[0].toLowerCase();
		}

		return after.join('');
	});

	return str;
}

myReplace("Let us go to the store", "store", "mall");
// should return "Let us go to the mall".
myReplace("He is Sleeping on the couch", "Sleeping", "sitting");
// should return "He is Sitting on the couch".
myReplace("This has a spellngi error", "spellngi", "spelling");
// should return "This has a spelling error".
myReplace("His name is Tom", "Tom", "john");
// should return "His name is John".
myReplace("Let us get back to more Coding", "Coding", "algorithms");
// should return "Let us get back to more Algorithms".
*/
/*
function whatIsInAName(collection, source) {
	// What's in a name?
	var arr = [];
	// Only change code below this line
	for(var c = 0; c < collection.length; c++){
		var sameProps = true;

		//Object.keys(source) could also get an array to loop through
		for (var prop in source) {
			if (! collection[c].hasOwnProperty(prop) || source[prop] != collection[c][prop]) {
				sameProps = false;
				break;
			}
		}

		if(sameProps){
			arr.push(collection[c]);
		}
	}
	// Only change code above this line
	return arr;
}

//cannot use "dot" notation on these props
whatIsInAName([{ first: "Romeo", last: "Montague" }, { first: "Mercutio", last: null }, { first: "Tybalt", last: "Capulet" }], { last: "Capulet" });
// should return [{ first: "Tybalt", last: "Capulet" }].
whatIsInAName([{ "a": 1 }, { "a": 1 }, { "a": 1, "b": 2 }], { "a": 1 });
// should return [{ "a": 1 }, { "a": 1 }, { "a": 1, "b": 2 }].
whatIsInAName([{ "a": 1, "b": 2 }, { "a": 1 }, { "a": 1, "b": 2, "c": 2 }], { "a": 1, "b": 2 });
// should return [{ "a": 1, "b": 2 }, { "a": 1, "b": 2, "c": 2 }].
whatIsInAName([{ "a": 1, "b": 2 }, { "a": 1 }, { "a": 1, "b": 2, "c": 2 }], { "a": 1, "c": 2 });
// should return [{ "a": 1, "b": 2, "c": 2 }].
*/
/*
function convertToRoman(num) {

	var numeralLookup = [
			['I','II','III','IV','V','VI','VII','VIII','IX'],
			['X','XX','XXX','XL','L','LX','LXX','LXXX','XC'],
			['C','CC','CCC','CD','D','DC','DCC','DCCC','CM'],
			['M', 'MM', 'MMM']
	];



	var numArr = num.toString(),
		romanString = '';

	for(var i = 0; i < numArr.length; i++ ){
		// Roman = i = lookup needed

		// 1 6 = X VI
		// X = 0 = numeralLookup[1][0]
		// VI = 1 = numeralLookup[0][5]

		// 6 4 9 = DC XL IX
		// DC = 0 = numeralLookup[2][0]
		// XL = 1 = numeralLookup[1][5]
		// IX = 2 = numeralLookup[0][8]

		// 8 3 = LXXX III
		// LXXX = 0 = numeralLookup[1][7]
		// III = 1 = numeralLookup[0][2]

		// 5 0 0 = D
		// D = 0 = numeralLookup[2][0]
		// '' = 1 = continue
		// '' = 2 = continue

		if(numArr[i]-1 < 0) continue;

		romanString += numeralLookup[numArr.length - 1 - i][numArr[i]-1];

	}

	console.log(romanString);
	return romanString;

}
*/
//1984 into 1000, 900, 80 and 4
//1000 + 900 + 80 + 4 = 1984, so 1984 = MCMLXXXIV

//convertToRoman(2);
// should return "II".
//convertToRoman(3);
// should return "III".
//convertToRoman(4);
// should return "IV".
//convertToRoman(5);
// should return "V".
//convertToRoman(9);
// should return "IX".
/*
convertToRoman(12);
// should return "XII".
convertToRoman(16);
// should return "XVI".
convertToRoman(29);
//  should return "XXIX".
convertToRoman(44);
//  should return "XLIV".
convertToRoman(45);
//  should return "XLV"
convertToRoman(68);
//  should return "LXVIII"

convertToRoman(83);
//  should return "LXXXIII"
convertToRoman(97);
//  should return "XCVII"
convertToRoman(99);
//  should return "XCIX"

convertToRoman(500);
//  should return "D"
convertToRoman(501);
//  should return "DI"
convertToRoman(649);
//  should return "DCXLIX"
convertToRoman(798);
//  should return "DCCXCVIII"
convertToRoman(891);
//  should return "DCCCXCI"
convertToRoman(1000);

//  should return "M"
convertToRoman(1004);
//  should return "MIV"
convertToRoman(1006);
//  should return "MVI"
convertToRoman(1023);
//  should return "MXXIII"
convertToRoman(2014);
//  should return "MMXIV"
convertToRoman(3999);
//  should return "MMMCMXCIX"
*/

/*

function diffArray(arr1, arr2) {
	var newArr = null;

	newArr = arr1.filter(function(value, i){
		if(arr2.indexOf(value) == -1){
			return true;
		}else{
			return false;
		}
	});

	newArr = newArr.concat(arr2.filter(function(value, i){
		if(arr1.indexOf(value) == -1){

			return true;
		}else{
			return false;
		}
	}));

	return newArr;
}

diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]);
//should return an array.
diffArray(["diorite", "andesite", "grass", "dirt", "pink wool", "dead shrub"], ["diorite", "andesite", "grass", "dirt", "dead shrub"]);
//should return an array.should return ["pink wool"].
diffArray(["andesite", "grass", "dirt", "pink wool", "dead shrub"], ["diorite", "andesite", "grass", "dirt", "dead shrub"]);
//should return an array.should return ["diorite", "pink wool"].
diffArray(["andesite", "grass", "dirt", "dead shrub"], ["andesite", "grass", "dirt", "dead shrub"]);
//should return an array.should return [].
diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]);
//should return an array.should return [4].
diffArray([1, "calf", 3, "piglet"], [1, "calf", 3, 4]);
//should return an array.should return ["piglet", 4].
diffArray([], ["snuffleupagus", "cookie monster", "elmo"]);
//should return an array.should return ["snuffleupagus", "cookie monster", "elmo"].
diffArray([1, "calf", 3, "piglet"], [7, "filly"]);
//should return an array.should return [1, "calf", 3, "piglet", 7, "filly"].
*/
/*
function sumAll(arr) {

	var sum = 0,
		min = Math.min.apply(null, arr),
		max = Math.max.apply(null, arr);


	for(var i = min; i <= max; i++){
		sum += i;
	}

	return(sum);
}

sumAll([1, 4]);
//should return a number.
sumAll([1, 4])
// should return 10.
sumAll([4, 1])
// should return 10.
sumAll([5, 10])
// should return 45.
sumAll([10, 5])
// should return 45.
*/

</script>
</body>
</html>
